# -*- coding: utf-8 -*-
"""En clase_Perceptrón.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1XOJsi7F69DD-_C1rRTL0fyZqI5oKVdS4
"""

import numpy as np # Paquete para el cálculo con matrices.
import random # Paquete para generar datos aleatorios de acuerdo a alguna distribucción.
import matplotlib.pyplot as plt # Paquete para realizar gráficos.

X_MAX = 1
Y_MAX = 1
X_MIN = 0
Y_MIN = 0

def line(w: np.array, x_matrix: np.array):
    """
    Inputs:
        w: es un np.array de dimensión 2.
        x: es un np.array de dimension n.        
    Output:
        Es el producto punto de w y (1, x).     
    """
    w = w.reshape(-1, 1)  #redefinido en vector columna
    x_matrix = x_matrix.reshape(-1, 1)
    n_row = len(x_matrix)
    ones = np.ones(n_row).reshape(-1, 1)   #vector de unos en forma de columna de tamaño n_row(n_filas) 
    one_x_matrix = np.hstack((ones, x_matrix)) #concatena el vector anterior con el de x
    return one_x_matrix.dot(w)

domain = np.arange(X_MIN, X_MAX, 0.001)

intercept = np.random.uniform(X_MIN, X_MAX) #da un número aleatorio en el intervalo y cada uno de ellos tiene la misma probabilidad de salir
slope = np.random.uniform(X_MIN, X_MAX)
w = np.array([intercept, slope]).reshape(1, -1)  # (intercept, slope) #vector fila con los dos resultados anteriores
image = line(w, domain)

def classify(x: float, y: float, w: np.array) -> int:
    """
    Inputs:
        x: un float entre (0, 1).
        y: un float entre (0, 1).
        w: un vector columna de dimensión 2.
    Output:
        Entrega la etiqueta asociada a cada punto (x, y) con respeto a la recta de parametro w. 
    """
    x_line = (y - w[0])/w[1]  # y - el intercept dividido por la pendiente
    
    if x > x_line:
        label = 1      #Label = etiqueta
    elif x < x_line:
        label = -1
    else:
        label = 0
        
    return label

def sample(size: int, w: np.array) -> list:
    """
    Inputs:
        size: Entero positivo que define el tamaño de la muestra. 
        w: Es vector columna de dimensión 2.
    Output:
        Una de datos de la forma (point, label).
    """
    w = w.reshape(-1, 1) #columna
    dataset = list()
    for _ in range(size):
        x = np.random.uniform(X_MIN, X_MAX)
        y = np.random.uniform(Y_MIN, Y_MAX)
        label = classify(x, y, w)
        point = np.array([x, y])
        dataset.append((point, label))
    return dataset

def plot_sample(dataset: list) -> None:
    for data in dataset:
        point = data[0]
        label = data[1]
        
        x = point[0]
        y = point[1]

        if label == 1:  
            plt.plot(x, y, 'r+')
        else: 
            
            plt.plot(x, y, 'bo')
    return None

dataset = sample(size=100, w=w)
plot_sample(dataset)
plt.plot(domain, image)
plt.axis([X_MIN, X_MAX, Y_MIN, Y_MAX])
plt.show()

"""## Algoritmo del Perceptrón"""

# Función objetivo

def sign_fuction(w, x):
    one = np.ones(1)
    one_x = np.hstack([one, x])
    return np.sign(w.dot(one_x)), one_x

def empirical_error(correct, incorrect):
    return len(incorrect)/(len(correct) + len(incorrect))

def train(iterations, dataset, alpha = 0.001):
    w = np.array([0, 0, 0])
    errors = list()
    correct = list()
    incorrect = list()
    
    for data in dataset:
        point = data[0]
        label = data[1] 
        sign, one_point = sign_fuction(w, point)
        if sign != label:
            incorrect.append(data)
        else:
            correct.append(data)
            
    errors.append(empirical_error(correct, incorrect))
    
    for i in range(iterations):
        
        if len(incorrect) == 0:
            intercept = -w[0]/w[2]
            slope = -w[1]/w[2]
            errors.append(empirical_error(correct, incorrect))
            return intercept, slope, errors
        
        else:
            random_data = random.choice(incorrect)  #Se selecciona un número al azar de los incorrectos 
            point = random_data[0]
            label = random_data[1]
            
            one = np.ones(1)
            one_point = np.hstack([one, point])
           
            w = w + alpha * (label * one_point)
            
            new_correct = list()
            new_incorrect  = list()
            
            for data in dataset:
                point = data[0]
                label = data[1] 
                sign, one_point = sign_fuction(w, point)
                if sign != label:
                    new_incorrect.append(data)
                else:
                    new_correct.append(data)
            
            
        correct = new_correct
        incorrect = new_incorrect
        
        errors.append(empirical_error(correct, incorrect))
        
    intercept = -w[0]/w[2]
    slope = -w[1]/w[2]
        
    return intercept, slope, errors

intercept, slope, errors = train(iterations=400, dataset=dataset)

plt.plot(errors)
plt.show()

hypothesis_w = np.array([intercept, slope])
hypothesis_w

hypothesis_image = line(hypothesis_w, domain) #h del conjunto de hipotesis

plot_sample(dataset)
plt.plot(domain, image)
plt.plot(domain, hypothesis_image)
plt.axis([X_MIN, X_MAX, Y_MIN, Y_MAX])
plt.show()

def score(hypothesis_w, new_dataset): #score: puntuación
    correct = 0
    incorrect = 0
    for data in new_dataset: 
        point = data[0]
        label = data[1]
        hypothesis_label = classify(x=point[0], y=point[1], w=hypothesis_w)
        if hypothesis_label != label:
            incorrect += 1
        else:
            correct += 1
    return incorrect/(correct + incorrect)

new_dataset = sample(size=100, w=w)

score(hypothesis_w, new_dataset)

plot_sample(new_dataset)
plt.plot(domain, image)
plt.plot(domain, hypothesis_image)
plt.axis([X_MIN, X_MAX, Y_MIN, Y_MAX])
plt.show()


